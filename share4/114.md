## Kotlin 泛型

### Why?
Kotlin的源码中经常碰见\<in T\>、\<out T\>

### 泛型不变性？
eg.已知 Cat 是 Animal 的子类
```kotlin
fun setAnimal(animal: Animal) {}

fun setAnimalList(animals: MutableList<Animal>) {}

fun main1() {
    setAnimal(Cat())

    //编译器在这里就会提示错误
    setAnimalList(mutableListOf<Cat>())
}
```
在正常情况下编译器会认，MutableLis\<Cat\> 与 MutableList\<Animal\> 两者之间不存在任何继承关系，  
它们也无法互相替代没有任何关系，也就是说泛型是不变的。

### 泛型型变？
为了解决泛型的不变性，根据父子关系可分为逆变和协变。

### 逆变？
eg.已知 XiaoMiTV 是 TV 的子类，Controller 为遥控器可以控制打开各个型号的TV
```kotlin
open class TV {
    open fun turnOn() {}
}

class XiaoMiTV : TV() {
    override fun turnOn() {}
}

class Controller<T : TV> {
    fun turnOn(tv: T) {
        tv.turnOn()
    }
}
```
接下来，有一个open()方法传入一个XiaoMiTV的遥控器，通过遥控器去打开XiaoMiTV。
```kotlin
fun open(controller: Controller<XiaoMiTV>) {
    val xiaoMiTV = XiaoMiTV()
    controller.turnOn(xiaoMiTV)
}

fun main() {
    val controller = Controller<XiaoMiTV>()
    open(controller)
}
```
因为 TV 是所有电视机的父类，Controller 内部将会处理所有电视机型号的开机，Controller\<TV\> 其实就相当于一个万能遥控器。
所以，理论上也可以通过传入一个万能遥控器 Controller\<TV\> 方式去打开XiaoMiTV电视。
```kotlin
fun main() {
    val controller = Controller<TV>()
    // 传入万能遥控器，报错类型不匹配
    open(controller)
}
```
这个时候可以通过 in 关键字进行逆变处理。

### 如何通过逆变解决编译器报错？
1、使用处逆变
修改泛型参数的使用处代码，比如修改open()方法，在 XiaoMiTV 的前面增加一个 in 关键字。
```kotlin
fun open(controller: Controller<in XiaoMiTV>) {
    val xiaoMiTV = XiaoMiTV()
    controller.turnOn(xiaoMiTV)
}
```
2、声明处逆变
修改 Controller 的代码，在泛型 T 的前面增加一个关键字 in。
```kotlin
class Controller<in T : TV> {
    fun turnOn(tv: T) {
        tv.turnOn()
    }
}
```
在这个场景下，遥控器与电视机之间的父子关系颠倒了。
XiaoMiTV 是 TV的子类，但是万能遥控 Controller\<TV\> 反过来成了小米遥控 Controller\<XiaoMiTV\>的子类。
![](data1.png)
这种父子关系颠倒的现象，就是泛型的逆变。